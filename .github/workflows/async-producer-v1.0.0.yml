# Async Producer - Publishes events and starts processing
# This workflow triggers async processing and exits immediately (non-blocking)

name: Async Producer Pipeline

on:
  workflow_dispatch:
    inputs:
      fibonacci_type:
        description: 'Type of Fibonacci computation'
        required: true
        default: 'standard'
        type: choice
        options:
          - standard
          - optimized
          - parallel
          - stress_test
      iterations:
        description: 'Number of Fibonacci iterations'
        required: false
        default: '100'
      batch_size:
        description: 'Batch size for processing'
        required: false
        default: '10'
      priority:
        description: 'Job priority'
        required: false
        default: 'normal'
        type: choice
        options:
          - low
          - normal
          - high
          - urgent
      callback_enabled:
        description: 'Enable GitHub callback when complete'
        required: false
        default: true
        type: boolean

env:
  PRODUCER_ACTION_ID: producer-${{ github.run_id }}-${{ github.run_attempt }}
  
jobs:
  # ================================
  # ASYNC JOB PUBLISHER
  # ================================
  publish-async-job:
    runs-on: self-hosted
    outputs:
      action-id: ${{ steps.publish.outputs.action-id }}
      correlation-id: ${{ steps.publish.outputs.correlation-id }}
      estimated-duration: ${{ steps.publish.outputs.estimated-duration }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: Generate Job Metadata
        id: metadata
        run: |
          CORRELATION_ID="corr-$(date +%s)-${{ github.run_id }}"
          CALLBACK_ENDPOINT=""
          
          # Generate callback webhook if enabled
          if [[ "${{ github.event.inputs.callback_enabled }}" == "true" ]]; then
            # In real scenario, this would be a webhook endpoint that triggers repository_dispatch
            CALLBACK_ENDPOINT="https://api.github.com/repos/${{ github.repository }}/dispatches"
          fi
          
          # Estimate processing duration based on job size
          JOB_SIZE="${{ github.event.inputs.job_size }}"
          ESTIMATED_DURATION=$((JOB_SIZE / 10 + 30))  # Rough estimate: 10 ops/sec + 30s overhead
          
          echo "correlation-id=$CORRELATION_ID" >> $GITHUB_OUTPUT
          echo "callback-endpoint=$CALLBACK_ENDPOINT" >> $GITHUB_OUTPUT
          echo "estimated-duration=${ESTIMATED_DURATION}s" >> $GITHUB_OUTPUT
          
          echo "ðŸ“‹ Job Metadata Generated:"
          echo "  Correlation ID: $CORRELATION_ID"
          echo "  Estimated Duration: ${ESTIMATED_DURATION}s"
          echo "  Callback: $([[ -n "$CALLBACK_ENDPOINT" ]] && echo "Enabled" || echo "Disabled")"

      - name: Publish Async Processing Job
        id: publish
        run: |
          ACTION_ID="${{ env.PRODUCER_ACTION_ID }}"
          CORRELATION_ID="${{ steps.metadata.outputs.correlation-id }}"
          
          # Create comprehensive job payload
          JOB_PAYLOAD=$(jq -n \
            --arg processing_job "${{ github.event.inputs.processing_job }}" \
            --arg job_size "${{ github.event.inputs.job_size }}" \
            --arg priority "${{ github.event.inputs.priority }}" \
            --arg correlation_id "$CORRELATION_ID" \
            --arg callback_enabled "${{ github.event.inputs.callback_enabled }}" \
            --arg callback_endpoint "${{ steps.metadata.outputs.callback-endpoint }}" \
            --arg repository "${{ github.repository }}" \
            --arg workflow_run_id "${{ github.run_id }}" \
            --arg actor "${{ github.actor }}" \
            --arg ref "${{ github.ref }}" \
            --arg sha "${{ github.sha }}" \
            --arg timestamp "$(date -Iseconds)" \
            '{
              processing_job: $processing_job,
              job_size: ($job_size | tonumber),
              priority: $priority,
              correlation_id: $correlation_id,
              callback_enabled: ($callback_enabled | test("true")),
              callback_endpoint: $callback_endpoint,
              github_context: {
                repository: $repository,
                workflow_run_id: $workflow_run_id,
                actor: $actor,
                ref: $ref,
                sha: $sha,
                triggered_at: $timestamp
              }
            }')
          
          echo "action-id=$ACTION_ID" >> $GITHUB_OUTPUT
          echo "correlation-id=$CORRELATION_ID" >> $GITHUB_OUTPUT
          echo "estimated-duration=${{ steps.metadata.outputs.estimated-duration }}" >> $GITHUB_OUTPUT
          
          echo "ðŸ“¤ Publishing async processing job..."
          echo "ðŸ†” Action ID: $ACTION_ID"
          echo "ðŸ“‹ Payload:"
          echo "$JOB_PAYLOAD" | jq '.'
          
          # Map processing job to appropriate event type
          case "${{ github.event.inputs.processing_job }}" in
            "math_computation")
              EVENT_TYPE="math-requested"
              # Transform to math-specific payload
              MATH_PAYLOAD=$(echo "$JOB_PAYLOAD" | jq '.operation = "fibonacci" | .iterations = .job_size')
              ./scripts/pubsub/publisher.sh "$ACTION_ID" "$EVENT_TYPE" "$MATH_PAYLOAD"
              ;;
            "data_processing")
              EVENT_TYPE="data-processing-requested"
              ./scripts/pubsub/publisher.sh "$ACTION_ID" "$EVENT_TYPE" "$JOB_PAYLOAD"
              ;;
            "ml_training")
              EVENT_TYPE="ml-training-requested" 
              ./scripts/pubsub/publisher.sh "$ACTION_ID" "$EVENT_TYPE" "$JOB_PAYLOAD"
              ;;
            "batch_processing")
              EVENT_TYPE="batch-processing-requested"
              ./scripts/pubsub/publisher.sh "$ACTION_ID" "$EVENT_TYPE" "$JOB_PAYLOAD"
              ;;
            *)
              echo "âŒ Unknown processing job type: ${{ github.event.inputs.processing_job }}"
              exit 1
              ;;
          esac
          
          echo "âœ… Job published successfully as: $EVENT_TYPE"

      - name: Start Fibonacci Background Processor
        run: |
          ACTION_ID="${{ steps.publish.outputs.action-id }}"
          
          echo "ðŸ§® Starting Fibonacci background processor for: $ACTION_ID"
          echo "ðŸ“Š Configuration:"
          echo "  Type: ${{ github.event.inputs.fibonacci_type }}"
          echo "  Iterations: ${{ github.event.inputs.iterations }}"
          echo "  Batch Size: ${{ github.event.inputs.batch_size }}"
          
          # Start Fibonacci subscriber
          nohup node ./scripts/pubsub/math-subscriber.js "$ACTION_ID" \
            > "/tmp/fibonacci-subscriber-$ACTION_ID.log" 2>&1 &
          
          SUBSCRIBER_PID=$!
          echo $SUBSCRIBER_PID > "/tmp/fibonacci-subscriber-$ACTION_ID.pid"
          
          echo "âœ… Fibonacci subscriber started with PID: $SUBSCRIBER_PID"
          echo "ðŸ“„ Logs: /tmp/fibonacci-subscriber-$ACTION_ID.log"
          echo "ðŸ”„ Processing will continue independently in background..."

      - name: Register Completion Monitor  
        if: github.event.inputs.callback_enabled == 'true'
        run: |
          ACTION_ID="${{ steps.publish.outputs.action-id }}"
          CORRELATION_ID="${{ steps.publish.outputs.correlation-id }}"
          
          echo "ðŸ‘ï¸  Registering completion monitor for callback..."
          
          # Start completion monitor that will trigger repository_dispatch
          nohup ./scripts/pubsub/completion-monitor.sh \
            "$ACTION_ID" \
            "$CORRELATION_ID" \
            "${{ github.repository }}" \
            "${{ secrets.GITHUB_TOKEN }}" \
            > "/tmp/completion-monitor-$ACTION_ID.log" 2>&1 &
          
          echo $! > "/tmp/completion-monitor-$ACTION_ID.pid"
          echo "âœ… Completion monitor registered with PID: $(cat /tmp/completion-monitor-$ACTION_ID.pid)"

      - name: Producer Summary
        run: |
          ACTION_ID="${{ steps.publish.outputs.action-id }}"
          CORRELATION_ID="${{ steps.publish.outputs.correlation-id }}"
          ESTIMATED_DURATION="${{ steps.publish.outputs.estimated-duration }}"
          
          cat >> $GITHUB_STEP_SUMMARY << EOF
          # ðŸš€ Async Job Published Successfully
          
          ## ðŸ“‹ Job Details
          
          | Attribute | Value |
          |-----------|-------|
          | **Action ID** | \`$ACTION_ID\` |
          | **Correlation ID** | \`$CORRELATION_ID\` |
          | **Processing Type** | \`${{ github.event.inputs.processing_job }}\` |
          | **Job Size** | \`${{ github.event.inputs.job_size }}\` iterations |
          | **Priority** | \`${{ github.event.inputs.priority }}\` |
          | **Estimated Duration** | \`$ESTIMATED_DURATION\` |
          | **Callback Enabled** | \`${{ github.event.inputs.callback_enabled }}\` |
          
          ## ðŸ”„ What Happens Next
          
          1. âš¡ **Background Processing Started**: Your job is running asynchronously
          2. ðŸ“Š **Outputs Being Streamed**: Real-time indexing to multiple datastores  
          3. $([[ "${{ github.event.inputs.callback_enabled }}" == "true" ]] && echo "ðŸ”” **GitHub Callback**: Consumer workflow will be triggered automatically when complete" || echo "â³ **Manual Check**: Use consumer workflow to check results later")
          
          ## ðŸ” Monitor Progress
          
          \`\`\`bash
          # Check current status
          ./scripts/pubsub/output-query-api.sh get-status "$ACTION_ID" "${{ github.event.inputs.processing_job }}"
          
          # Stream logs in real-time
          ./scripts/pubsub/output-query-api.sh stream-logs "$ACTION_ID" "${{ github.event.inputs.processing_job }}"
          
          # Check background process logs
          tail -f /tmp/*-subscriber-$ACTION_ID.log
          \`\`\`
          
          ## ðŸŽ¯ Next Step
          
          This workflow is now **complete and non-blocking**. The actual processing continues in the background.
          $([[ "${{ github.event.inputs.callback_enabled }}" == "true" ]] && echo "The **Async Consumer** workflow will be automatically triggered when processing completes." || echo "Manually trigger the **Async Consumer** workflow later to retrieve results.")
          
          **Producer job finished in seconds, processing continues asynchronously! ðŸŽ‰**
          EOF
          
          echo "ðŸŽ‰ Producer workflow complete! Processing continues in background."
          echo "ðŸ†” Track with Action ID: $ACTION_ID"