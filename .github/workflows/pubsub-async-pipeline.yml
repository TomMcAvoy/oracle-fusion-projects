# Pub/Sub Async Pipeline Template
# Publisher: GitHub Actions Runner
# Subscribers: Action scripts that subscribe to action-id patterns
# Message Broker: Redis pub/sub with fallback to file-based messaging

name: Pub/Sub Async State Machine

on:
  push:
    branches: [ master, main ]
  pull_request:
    branches: [ master, main ]
  workflow_dispatch:
    inputs:
      action_config:
        description: 'Action configuration JSON'
        required: false
        default: '{"timeout": 300, "message_broker": "redis", "retry_policy": "exponential"}'

env:
  ACTION_ID: pipeline-${{ github.run_id }}-${{ github.run_attempt }}
  MESSAGE_BROKER: ${{ fromJson(github.event.inputs.action_config || '{"message_broker": "redis"}').message_broker }}
  BROKER_URL: redis://127.0.0.1:6379
  FALLBACK_BROKER: file:///tmp/pipeline-messages

jobs:
  # ================================
  # PUBLISHER: Initialize and Publish Events
  # ================================
  event-publisher:
    runs-on: self-hosted
    outputs:
      action-id: ${{ steps.init.outputs.action-id }}
      broker-type: ${{ steps.init.outputs.broker-type }}
    steps:
      - name: Initialize Event Publisher
        id: init
        run: |
          ACTION_ID="${{ env.ACTION_ID }}"
          echo "action-id=$ACTION_ID" >> $GITHUB_OUTPUT
          
          # Initialize message broker
          if command -v redis-cli >/dev/null 2>&1 && redis-cli ping >/dev/null 2>&1; then
            BROKER_TYPE="redis"
            echo "📡 Using Redis message broker"
          else
            BROKER_TYPE="file"
            echo "📁 Using file-based message broker"
            mkdir -p /tmp/pipeline-messages
          fi
          
          echo "broker-type=$BROKER_TYPE" >> $GITHUB_OUTPUT
          
          # Publish pipeline-initialized event
          ./scripts/pubsub/publisher.sh "$ACTION_ID" "pipeline-initialized" \
            '{"repository":"${{ github.repository }}","ref":"${{ github.ref }}","actor":"${{ github.actor }}"}'

      - name: Publish Build Request
        run: |
          # Publish build-requested event - any build subscriber can pick this up
          ./scripts/pubsub/publisher.sh "${{ steps.init.outputs.action-id }}" "build-requested" \
            '{"event_name":"${{ github.event_name }}","commit_sha":"${{ github.sha }}","branch":"${{ github.ref_name }}"}'

      - name: Publish Secrets Request
        run: |
          # Publish secrets-requested event - any secrets subscriber can pick this up
          ./scripts/pubsub/publisher.sh "${{ steps.init.outputs.action-id }}" "secrets-requested" \
            '{"repository":"${{ github.repository }}","run_id":"${{ github.run_id }}"}'

  # ================================
  # SUBSCRIBER: Build Action
  # ================================
  build-subscriber:
    needs: event-publisher
    runs-on: self-hosted
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: Subscribe and Execute Build
        timeout-minutes: 10
        run: |
          ACTION_ID="${{ needs.event-publisher.outputs.action-id }}"
          
          # Start build subscriber - it will listen for build-requested:$ACTION_ID
          ./scripts/pubsub/build-subscriber.sh "$ACTION_ID" &
          SUBSCRIBER_PID=$!
          
          # Wait for completion or timeout
          wait $SUBSCRIBER_PID || {
            echo "⚠️  Build subscriber escaped or failed"
            # Publish escape event
            ./scripts/pubsub/publisher.sh "$ACTION_ID" "build-escaped" '{"reason":"timeout","exit_code":124}'
          }

  # ================================
  # SUBSCRIBER: Secrets Action
  # ================================
  secrets-subscriber:
    needs: event-publisher
    runs-on: self-hosted
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: Subscribe and Execute Secrets Fetch
        timeout-minutes: 8
        run: |
          ACTION_ID="${{ needs.event-publisher.outputs.action-id }}"
          
          # Start secrets subscriber - it will listen for secrets-requested:$ACTION_ID
          ./scripts/pubsub/secrets-subscriber.sh "$ACTION_ID" &
          SUBSCRIBER_PID=$!
          
          # Wait for completion or timeout
          wait $SUBSCRIBER_PID || {
            echo "⚠️  Secrets subscriber escaped or failed"
            ./scripts/pubsub/publisher.sh "$ACTION_ID" "secrets-escaped" '{"reason":"timeout","exit_code":124}'
          }

  # ================================
  # SUBSCRIBER: Deploy Action (Multi-dependency)
  # ================================
  deploy-subscriber:
    needs: [event-publisher, build-subscriber, secrets-subscriber]
    runs-on: self-hosted
    if: always()  # Always run to check for completion events
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: Subscribe and Execute Deploy
        timeout-minutes: 15
        run: |
          ACTION_ID="${{ needs.event-publisher.outputs.action-id }}"
          
          # Start deploy subscriber - it will listen for multiple completion events
          # Pattern: (build-completed|build-escaped):$ACTION_ID AND (secrets-completed|secrets-escaped):$ACTION_ID
          ./scripts/pubsub/deploy-subscriber.sh "$ACTION_ID" &
          SUBSCRIBER_PID=$!
          
          # Wait for completion or timeout
          wait $SUBSCRIBER_PID || {
            echo "⚠️  Deploy subscriber escaped or failed"
            ./scripts/pubsub/publisher.sh "$ACTION_ID" "deploy-escaped" '{"reason":"timeout","exit_code":124}'
          }

  # ================================
  # OUTPUT RETRIEVAL - GitHub queries indexed outputs
  # ================================
  output-retrieval:
    needs: [event-publisher, build-subscriber, secrets-subscriber]
    runs-on: self-hosted
    if: always()  # Always run to retrieve outputs regardless of job status
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: Query Build Outputs
        id: build-outputs
        run: |
          ACTION_ID="${{ needs.event-publisher.outputs.action-id }}"
          
          echo "🔍 Querying build outputs asynchronously..."
          
          # Get build status
          if BUILD_STATUS=$(./scripts/pubsub/output-query-api.sh get-status "$ACTION_ID" build); then
            echo "build-status=$BUILD_STATUS" >> $GITHUB_OUTPUT
            echo "📊 Build Status: $BUILD_STATUS"
          fi
          
          # Get last 50 lines of build logs
          echo "📄 Build Logs (last 50 lines):"
          ./scripts/pubsub/output-query-api.sh get-logs "$ACTION_ID" build 50 || echo "No logs found"
          
          # Search for specific patterns (errors, warnings)
          echo "🔍 Searching for errors:"
          ./scripts/pubsub/output-query-api.sh search "$ACTION_ID" build "error|failed|exception" || echo "No errors found in logs"

      - name: Query Secrets Outputs  
        id: secrets-outputs
        run: |
          ACTION_ID="${{ needs.event-publisher.outputs.action-id }}"
          
          echo "🔐 Querying secrets fetch outputs..."
          
          # Get secrets fetch status
          if SECRETS_STATUS=$(./scripts/pubsub/output-query-api.sh get-status "$ACTION_ID" secrets); then
            echo "secrets-status=$SECRETS_STATUS" >> $GITHUB_OUTPUT
            echo "📊 Secrets Status: $SECRETS_STATUS"
          fi
          
          # Get secrets logs (without sensitive data)
          echo "📄 Secrets Logs (last 20 lines):"
          ./scripts/pubsub/output-query-api.sh get-logs "$ACTION_ID" secrets 20 | grep -v "PASS\|TOKEN\|SECRET" || echo "No logs found"

      - name: Generate Pipeline Report
        run: |
          ACTION_ID="${{ needs.event-publisher.outputs.action-id }}"
          BUILD_STATUS="${{ steps.build-outputs.outputs.build-status }}"
          SECRETS_STATUS="${{ steps.secrets-outputs.outputs.secrets-status }}"
          
          echo "📋 Pipeline Report for $ACTION_ID"
          echo "=================================="
          echo "Build: $BUILD_STATUS"
          echo "Secrets: $SECRETS_STATUS"
          echo "Repository: ${{ github.repository }}"
          echo "Commit: ${{ github.sha }}"
          echo "Actor: ${{ github.actor }}"
          echo "Timestamp: $(date -Iseconds)"
          
          # Create GitHub job summary
          cat >> $GITHUB_STEP_SUMMARY << EOF
          # 🚀 Async Pipeline Report
          
          **Action ID:** \`$ACTION_ID\`
          
          ## 📊 Status Summary
          
          | Stage | Status | Details |
          |-------|--------|---------|
          | Build | \`$BUILD_STATUS\` | Outputs streamed to indexed datastore |
          | Secrets | \`$SECRETS_STATUS\` | Vault/fallback authentication |
          
          ## 🔗 Query Commands
          
          You can query outputs asynchronously using:
          
          \`\`\`bash
          # Get current status
          ./scripts/pubsub/output-query-api.sh get-status "$ACTION_ID" build
          
          # Stream logs in real-time  
          ./scripts/pubsub/output-query-api.sh stream-logs "$ACTION_ID" build
          
          # Search for specific patterns
          ./scripts/pubsub/output-query-api.sh search "$ACTION_ID" build "your-search-term"
          \`\`\`
          
          ## 📡 Data Sources
          
          Outputs are automatically streamed to:
          - 📊 ElasticSearch (searchable logs)
          - 🍃 MongoDB (structured data)  
          - 📡 Redis Streams (real-time)
          - ☁️ S3 (archival)
          - 📦 GitHub Artifacts (fallback)
          
          EOF

  # ================================
  # REAL-TIME OUTPUT STREAMING (Optional)
  # ================================
  stream-outputs:
    needs: [event-publisher, build-subscriber]
    runs-on: self-hosted
    if: contains(github.event.inputs.action_config, 'stream_enabled')
    steps:
      - name: Stream Build Outputs in Real-Time
        timeout-minutes: 15
        run: |
          ACTION_ID="${{ needs.event-publisher.outputs.action-id }}"
          
          echo "📡 Starting real-time output streaming..."
          
          # Stream build outputs as they happen
          ./scripts/pubsub/output-query-api.sh stream-logs "$ACTION_ID" build &
          STREAM_PID=$!
          
          # Monitor for completion
          while kill -0 $STREAM_PID 2>/dev/null; do
            sleep 5
            
            # Check if build completed
            if ./scripts/pubsub/output-query-api.sh get-status "$ACTION_ID" build | grep -q "completed"; then
              echo "✅ Build completed - stopping stream"
              kill $STREAM_PID 2>/dev/null || true
              break
            fi
          done

  # ================================
  # CLEANUP SUBSCRIBER
  # ================================
  cleanup-subscriber:
    needs: [event-publisher, build-subscriber, secrets-subscriber, deploy-subscriber, output-retrieval]
    runs-on: self-hosted
    if: always()
    steps:
      - name: Subscribe and Execute Cleanup
        run: |
          ACTION_ID="${{ needs.event-publisher.outputs.action-id }}"
          
          echo "🧹 Starting cleanup process..."
          
          # Query final pipeline state
          echo "📊 Final Pipeline State:"
          ./scripts/pubsub/output-query-api.sh get-status "$ACTION_ID" all || echo "No final state available"
          
          # Cleanup subscriber listens for pipeline-completed or any escaped events
          ./scripts/pubsub/cleanup-subscriber.sh "$ACTION_ID"